/*
 *  @file  : WndSorter.cpp
 *  @author: slx
 *  @date  : 2019-01-18 11:20:28.395
 *  @note  : Generated by SlxTemplates
 */

#include <Windows.h>
#include <CommCtrl.h>
#pragma warning(disable: 4786)
#include <tchar.h>
#include "resource.h"
#include <set>
#include <memory>
#include <algorithm>
#include <unordered_set>
#include <unordered_map>
#include <string>

using namespace std;
using namespace tr1;

#define _WND_CAPTION L"__WndSorter_shilyx"

struct WndInfo {
    HWND hWnd;
    HWND hAddress;
    DWORD dwTime;
    wstring strAddress;

    DWORD GetAliveSeconds() const {
        return (GetTickCount() - dwTime) / 1000;
    }
};

typedef std::tr1::unordered_map<HWND, std::tr1::shared_ptr<WndInfo> > Map;
typedef std::list<std::tr1::shared_ptr<WndInfo> > List;

class CWndSorterDialog {
#define WNDSORTER_OBJECT_PROP_NAME L"__WndSorterObject"

    enum {
        WM_NOTIFY_CALLBACK = WM_USER + 0x12,
    };

    enum {
        MI_ABOUT = 11,
        MI_QUIT,
    };

public:
    CWndSorterDialog(HINSTANCE hInstance, LPCWSTR lpTemplate, HWND hParent, int nShowCmd)
        : m_hInstance(hInstance)
        , m_lpTemplate(lpTemplate)
        , m_hwndDlg(NULL)
        , m_hParent(hParent)
        , m_nShowCmd(nShowCmd)
        , m_WM_REBUILDTOOLBAR(RegisterWindowMessageW(L"TaskbarCreated")) {
        ZeroMemory(&m_nid, sizeof(m_nid));
        m_nid.cbSize = sizeof(m_nid);
    }

    int Run() {
        HWND hwndDlg = CreateDialogParamW(m_hInstance, m_lpTemplate, m_hParent, WndSorterDialogProc, (LPARAM)this);

        if (IsWindow(hwndDlg)) {
            ShowWindow(hwndDlg, m_nShowCmd);
            UpdateWindow(hwndDlg);

            MSG msg;

            while (TRUE) {
                int nRet = GetMessageW(&msg, NULL, 0, 0);

                if (nRet < 0) {
                    break;
                }

                if (nRet == 0) {
                    return (int)msg.wParam;
                }

                if (!IsDialogMessageW(hwndDlg, &msg)) {
                    TranslateMessage(&msg);
                    DispatchMessageW(&msg);
                }
            }
        }

        return 0;
    }

private:
    static INT_PTR CALLBACK WndSorterDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam) {
        if (uMsg == WM_INITDIALOG) {
            SetPropW(hwndDlg, WNDSORTER_OBJECT_PROP_NAME, (HANDLE)lParam);
        }

        CWndSorterDialog *pWndSorterDialog = (CWndSorterDialog *)GetProp(hwndDlg, WNDSORTER_OBJECT_PROP_NAME);

        if (pWndSorterDialog != NULL) {
            return pWndSorterDialog->WndSorterDialogPrivateProc(hwndDlg, uMsg, wParam, lParam);
        }

        return FALSE;
    }

    INT_PTR WndSorterDialogPrivateProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam) {
        switch (uMsg) {
        case WM_INITDIALOG:
            m_nid.hWnd = hwndDlg;
            m_nid.uID = 1;
            m_nid.uCallbackMessage = WM_NOTIFY_CALLBACK;
            m_nid.hIcon = LoadIconW(m_hInstance, MAKEINTRESOURCEW(IDI_MAINFRAME));
            m_nid.uFlags = NIF_TIP | NIF_MESSAGE | NIF_ICON;
            lstrcpynW(m_nid.szTip, L"WndSorter, close duplicate explorer window automatically", RTL_NUMBER_OF(m_nid.szTip));
            m_nid.uTimeout = 3000;
            m_nid.dwInfoFlags = NIIF_INFO;

            Shell_NotifyIconW(NIM_ADD, &m_nid);

            SetClassLongPtrW(hwndDlg, GCL_HICON, (LONG_PTR)m_nid.hIcon);
            SetClassLongPtrW(hwndDlg, GCL_HICONSM, (LONG_PTR)m_nid.hIcon);

            m_hwndDlg = hwndDlg;
            OnInitDialog();

            return 0;

        case WM_CLOSE:
            ShowWindow(hwndDlg, SW_HIDE);
            return 0;

        case WM_DESTROY:
            OnDestroy();
            PostQuitMessage(0);
            Shell_NotifyIconW(NIM_DELETE, &m_nid);
            RemovePropW(hwndDlg, WNDSORTER_OBJECT_PROP_NAME);
            return 0;

        case WM_NOTIFY_CALLBACK:
            if (lParam == WM_RBUTTONUP) {
                POINT pt;

                GetCursorPos(&pt);
                SetForegroundWindow(hwndDlg);

                HMENU hMenu = CreatePopupMenu();

                AppendMenuW(hMenu, MF_STRING, MI_ABOUT, L"&About...");
                AppendMenuW(hMenu, MF_SEPARATOR, 0, NULL);
                AppendMenuW(hMenu, MF_STRING, MI_QUIT, L"&Quit");

                switch (TrackPopupMenu(hMenu, TPM_RETURNCMD | TPM_NONOTIFY, pt.x, pt.y, 0, hwndDlg, NULL)) {
                case MI_ABOUT:
                    if (IsWindowEnabled(hwndDlg)) {
                        MessageBoxW(
                            hwndDlg,
                            L"WndSorter application\r\n\r\n"
                            L"Close duplicate explorer window automatically\r\n\r\n"
                            L"https://github.com/shilyx/WndSorter",
                            L"information",
                            MB_SYSTEMMODAL | MB_ICONINFORMATION);
                    }
                    break;

                case MI_QUIT:
                    DestroyWindow(hwndDlg);
                    break;

                default:
                    break;
                }

                DestroyMenu(hMenu);
            }
            return 0;

        case WM_TIMER:
            if (wParam == 1) {
                OnTick1();
            }
            break;

#ifdef _DEBUG
        case WM_LBUTTONDOWN:
            ShowBalloon(L"title", L"balloon tip content", NIIF_WARNING, 4000);
            break;
#endif

        default:
            if (uMsg == m_WM_REBUILDTOOLBAR) {
                Shell_NotifyIconW(NIM_ADD, &m_nid);
            }
            break;
        }

        return FALSE;
    }

    void ShowBalloon(LPCWSTR lpTitle, LPCWSTR lpContent, DWORD dwInfoFlag = NIIF_INFO, UINT nTimeout = 3000) {
        NOTIFYICONDATAW nid = m_nid;

        nid.uFlags |= NIF_INFO;
        lstrcpynW(nid.szInfo, lpContent, RTL_NUMBER_OF(nid.szInfo));
        lstrcpynW(nid.szInfoTitle, lpTitle, RTL_NUMBER_OF(nid.szInfoTitle));
        nid.uTimeout = nTimeout;

        if (dwInfoFlag == 0) {
            dwInfoFlag = NIIF_INFO;
        }

        nid.dwInfoFlags = dwInfoFlag;

        Shell_NotifyIconW(NIM_MODIFY, &nid);
    }

    void OnInitDialog() {
        SetWindowTextW(m_hwndDlg, _WND_CAPTION);
        SetTimer(m_hwndDlg, 1, 1000, NULL);
    }

    void OnDestroy() {
        KillTimer(m_hwndDlg, 1);
    }

    void OnTick1() {
        List listWnds = GetAllWnds();

        // 更新窗口持续时间
        for (List::iterator it = listWnds.begin(); it != listWnds.end(); ++it) {
            shared_ptr<WndInfo> pWndInfo = *it;
            DWORD dwTime = m_mapWndTimes[pWndInfo->hWnd];

            if (dwTime > 0) {
                pWndInfo->dwTime = dwTime;
            } else {
                m_mapWndTimes[pWndInfo->hWnd] = pWndInfo->dwTime;
            }
        }

        // 
        {
            unordered_map<HWND, DWORD>::iterator it = m_mapWndTimes.begin();

            while (it != m_mapWndTimes.end()) {
                if (IsWindow(it->first)) {
                    ++it;
                } else {
                    it = m_mapWndTimes.erase(it);
                }
            }
        }

        // 关闭重复的超时窗口
        set<wstring> setWndAddresses;

        for (List::const_iterator it = listWnds.begin(); it != listWnds.end(); ++it) {
            shared_ptr<WndInfo> pWndInfo = *it;

            if (pWndInfo->GetAliveSeconds() < 30) {
                continue;
            }

            if (setWndAddresses.count(pWndInfo->strAddress) > 0) {
                if (pWndInfo->GetAliveSeconds() > 10) {
                    PostMessage(pWndInfo->hWnd, WM_SYSCOMMAND, SC_CLOSE, 0);
                }
            } else {
                setWndAddresses.insert(pWndInfo->strAddress);
            }
        }
    }

    List GetAllWnds() {
        List listWnds;
        EnumWindows(EnumAllWndsProc, (LPARAM)&listWnds);
        return listWnds;
    }

    static BOOL CALLBACK EnumAllSubWndsProc(HWND hWnd, LPARAM lParam) {
        WCHAR szClassName[1024] = L"";

        GetClassNameW(hWnd, szClassName, RTL_NUMBER_OF(szClassName));

        if (lstrcmpiW(szClassName, L"Breadcrumb Parent") == 0) {
            *(HWND *)lParam = hWnd;
            return FALSE;
        }

        return TRUE;
    }

    static BOOL CALLBACK EnumAllWndsProc(HWND hWnd, LPARAM lParam) {
        HWND hWorkW = FindWindowExW(hWnd, NULL, L"WorkerW", NULL);

        if (hWorkW) {
            HWND hBreadcrumb_Parent = NULL;

            EnumChildWindows(hWorkW, EnumAllSubWndsProc, (LPARAM)&hBreadcrumb_Parent);

            if (IsWindow(hBreadcrumb_Parent)) {
                HWND hAddress = FindWindowEx(hBreadcrumb_Parent, NULL, L"ToolbarWindow32", NULL);

                if (IsWindow(hAddress)) {
                    shared_ptr<WndInfo> pWndInfo(new WndInfo());
                    WCHAR szText[1024] = L"";;

                    pWndInfo->hWnd = hWnd;
                    pWndInfo->hAddress = hAddress;
                    GetWindowTextW(pWndInfo->hAddress, szText, RTL_NUMBER_OF(szText));
                    pWndInfo->strAddress = szText;
                    pWndInfo->dwTime = GetTickCount();

                    ((List *)lParam)->push_back(pWndInfo);
                }
            }
        }

        return TRUE;
    }

private:
    HWND m_hwndDlg;
    HWND m_hParent;
    HINSTANCE m_hInstance;
    LPCWSTR m_lpTemplate;
    int m_nShowCmd;
    NOTIFYICONDATAW m_nid;
    UINT m_WM_REBUILDTOOLBAR;
    unordered_map<HWND, DWORD> m_mapWndTimes;
};

int APIENTRY wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, int nShowCmd) {
    InitCommonControls();
    if (IsWindow(FindWindowW(L"#32770", _WND_CAPTION))) {
        MessageBoxW(NULL, L"another instance exists already", NULL, MB_ICONERROR);
        return 0;
    }
    return CWndSorterDialog(hInstance, MAKEINTRESOURCEW(IDD_DIALOG), NULL, SW_HIDE).Run();
}
